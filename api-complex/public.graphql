
      input loginUserInput {
  clientMutationId: String
  userName: String!
  password: String!
}

type loginUserPayload {
  clientMutationId: String
  viewer: Viewer
  token: String
}

   input registerUserInput {
            clientMutationId: String
            userName: String!
            password: String!
          }

          type registerUserPayload {
            clientMutationId: String
            viewer: Viewer
            token: String
            message: String
          }
        
  
    # State of field
    enum eSOF {
      assigned
      void
    }
  
  
      # State of Connection
      enum eSOC {
        empty
        any
      }
    
  
    type PageInfo {
      hasNextPage: Boolean!
      hasPreviousPage: Boolean!
      startCursor: String
      endCursor: String
      count: Int
    }
  
  
      enum ImageSize {
        small
        middle
        large
      }
    
  
      scalar JSON
    
  
      input File {
        name: String!
        type: String!
        size: Int!
        path: String!
      }
  
  
      # Mutation type
      enum MutationKind {
        CREATE
        UPDATE
        DELETE
        LINK
        UNLINK
      }
    
  
      input WhereBoolean {
        eq: Boolean
        ne: Boolean
        exists: Boolean
      }
  
  
      input WhereDate {
        eq: Date
        gt: Date
        gte: Date
        lt: Date
        lte: Date
        ne: Date
        in: [Date!]
        nin: [Date!]
        and: [WhereDate!]
        or: [WhereDate!]
        nor: [WhereDate!]
        not: [WhereDate!]
        exists: Boolean
        match: String
      }
  
  
      input WhereFloat {
        eq: Float
        gt: Float
        gte: Float
        lt: Float
        lte: Float
        ne: Float
        in: [Float!]
        nin: [Float!]
        and: [WhereFloat!]
        or: [WhereFloat!]
        nor: [WhereFloat!]
        not: [WhereFloat!]
        exists: Boolean
      }
  
  
      input WhereID {
        eq: ID
        ne: ID
        in: [ID!]
        nin: [ID!]
        and: [WhereID!]
        or: [WhereID!]
        nor: [WhereID!]
        not: [WhereID!]
        exists: Boolean
      }
  
  
      input WhereInt {
        eq: Int
        gt: Int
        gte: Int
        lt: Int
        lte: Int
        ne: Int
        in: [Int!]
        nin: [Int!]
        and: [WhereInt!]
        or: [WhereInt!]
        nor: [WhereInt!]
        not: [WhereInt!]
        exists: Boolean
      }
  
  
      input WhereString {
        eq: String
        ne: String
        in: [String!]
        nin: [String!]
        and: [WhereString!]
        or: [WhereString!]
        nor: [WhereString!]
        not: [WhereString!]
        exists: Boolean
        match: String
        imatch: String
      }
  
  
      input WhereListOfStrings {
        contains: String
        some: [String!]
        every: [String!]
        except: String
        none: [String!]
      }
  
  
      input WhereMutationKind {
        in: [MutationKind!]
      }
  
  
# # User


input EmbedUserFilter {
  or: [EmbedUserFilterItem]
  and: [EmbedUserFilterItem]
  some: UserFilter
  none: UserFilter
  every: UserFilter
}

input EmbedUserFilterItem {
  some: UserFilter
  none: UserFilter
  every: UserFilter
}

input UserFilter {
  or: [UserFilterItem]
  and: [UserFilterItem]
  userName: WhereString
  password: WhereString
  isAdmin: WhereBoolean
  isSystem: WhereBoolean
  enabled: WhereBoolean
  id: WhereID
}

input UserComplexFilter {
  or: [UserComplexFilter]
  and: [UserComplexFilter]
  userName: WhereString
  password: WhereString
  isAdmin: WhereBoolean
  isSystem: WhereBoolean
  enabled: WhereBoolean
  id: WhereID
}

input UserFilterItem {
  userName: WhereString
  password: WhereString
  isAdmin: WhereBoolean
  isSystem: WhereBoolean
  enabled: WhereBoolean
  id: WhereID
}

input UserFilterSubscriptionsItem {
  userName: WhereString
  password: WhereString
  isAdmin: WhereBoolean
  isSystem: WhereBoolean
  enabled: WhereBoolean
  id: WhereID
}

input UserFilterSubscriptions {
  or: [UserFilterSubscriptions]
  and: [UserFilterSubscriptions]
  mutation: WhereMutationKind
  node: UserFilterSubscriptionsItem
  previous: UserFilterSubscriptionsItem
  updatedFields: WhereListOfStrings
}

type User implements Node{
  # # User Name
  userName: String!
  # # Password
  password: String!
  # # Is Admin
  isAdmin: Boolean
  # # Is System
  isSystem: Boolean
  # # Enabled
  enabled: Boolean
  # # Id
  id: ID!
  # # Todos  
  todos(after: String, first: Int, before: String, last: Int, limit: Int, skip: Int, orderBy: [ToDoItemSortOrder], filter:ToDoItemComplexFilter ): UserHasManyTodosConnection  
}



  
# # To Do Item


input EmbedToDoItemFilter {
  or: [EmbedToDoItemFilterItem]
  and: [EmbedToDoItemFilterItem]
  some: ToDoItemFilter
  none: ToDoItemFilter
  every: ToDoItemFilter
}

input EmbedToDoItemFilterItem {
  some: ToDoItemFilter
  none: ToDoItemFilter
  every: ToDoItemFilter
}

input ToDoItemFilter {
  or: [ToDoItemFilterItem]
  and: [ToDoItemFilterItem]
  name: WhereString
  description: WhereString
  done: WhereBoolean
  dueToDate: WhereDate
  user: WhereString
  id: WhereID
  createdBy: WhereID
  updateBy: WhereID
  createdAt: WhereDate
  updatedAt: WhereDate
}

input ToDoItemComplexFilter {
  or: [ToDoItemComplexFilter]
  and: [ToDoItemComplexFilter]
  name: WhereString
  description: WhereString
  done: WhereBoolean
  dueToDate: WhereDate
  user: WhereString
  id: WhereID
  createdBy: WhereID
  updateBy: WhereID
  createdAt: WhereDate
  updatedAt: WhereDate
}

input ToDoItemFilterItem {
  name: WhereString
  description: WhereString
  done: WhereBoolean
  dueToDate: WhereDate
  user: WhereString
  id: WhereID
  createdBy: WhereID
  updateBy: WhereID
  createdAt: WhereDate
  updatedAt: WhereDate
}

input ToDoItemFilterSubscriptionsItem {
  name: WhereString
  description: WhereString
  done: WhereBoolean
  dueToDate: WhereDate
  user: WhereString
  id: WhereID
  createdBy: WhereID
  updateBy: WhereID
  createdAt: WhereDate
  updatedAt: WhereDate
}

input ToDoItemFilterSubscriptions {
  or: [ToDoItemFilterSubscriptions]
  and: [ToDoItemFilterSubscriptions]
  mutation: WhereMutationKind
  node: ToDoItemFilterSubscriptionsItem
  previous: ToDoItemFilterSubscriptionsItem
  updatedFields: WhereListOfStrings
}

type ToDoItem implements Node{
  # # Name
  name: String
  # # Description
  description: String
  # # Done
  done: Boolean
  # # Due To Date
  dueToDate: Date
  # # Id
  id: ID!
  # # Created At
  createdAt: Date
  # # Updated At
  updatedAt: Date
  # # User
  user: User

  # # Created By
  createdBy: User

  # # Update By
  updateBy: User

}



  
      scalar Date
    
  
      scalar ID
    
  enum UserSortOrder {
  userNameAsc
  userNameDesc
  passwordAsc
  passwordDesc
  isAdminAsc
  isAdminDesc
  isSystemAsc
  isSystemDesc
  enabledAsc
  enabledDesc
  idAsc
  idDesc
}
  enum ToDoItemSortOrder {
  nameAsc
  nameDesc
  descriptionAsc
  descriptionDesc
  doneAsc
  doneDesc
  dueToDateAsc
  dueToDateDesc
  idAsc
  idDesc
  createdAtAsc
  createdAtDesc
  updatedAtAsc
  updatedAtDesc
}
  # Input types for basic CUD

# input type for User
input createUserInput {
  clientMutationId: String
  id: ID
  userName: String!
  password: String!
  isAdmin: Boolean
  isSystem: Boolean
  enabled: Boolean
  todos: [embedToDoItemInput]
}


input embedUserInput {
  clientMutationId: String
  id: ID
  userName: String
  password: String
  isAdmin: Boolean
  isSystem: Boolean
  enabled: Boolean
  todos: [embedToDoItemInput]
}


# Payload type for User
type createUserPayload {
  clientMutationId: String
  viewer: Viewer
  user: UsersEdge
}

# input type for User
input updateUserInput {
  clientMutationId: String
  id: ID
  userName: String
  password: String
  isAdmin: Boolean
  isSystem: Boolean
  enabled: Boolean
  todos: [embedToDoItemInput]
  todosUnlink: [embedToDoItemInput]
  todosCreate: [createToDoItemInput]
}

# Payload type for User
type updateUserPayload {
  clientMutationId: String
  viewer: Viewer
  user: User
}

# input type for User
input deleteUserInput {
  clientMutationId: String
  id: ID
  userName: String
}

# Payload type for User
type deleteUserPayload {
  clientMutationId: String
  viewer: Viewer
  deletedItemId: ID
  user: User
}

  # Input types for basic CUD

# input type for ToDoItem
input createToDoItemInput {
  clientMutationId: String
  id: ID
  name: String
  description: String
  done: Boolean
  dueToDate: Date
  createdAt: Date
  updatedAt: Date
  user: embedUserInput
  createdBy: embedUserInput
  updateBy: embedUserInput
}


input embedToDoItemInput {
  clientMutationId: String
  id: ID
  name: String
  description: String
  done: Boolean
  dueToDate: Date
  createdAt: Date
  updatedAt: Date
  user: embedUserInput
  createdBy: embedUserInput
  updateBy: embedUserInput
}


# Payload type for ToDoItem
type createToDoItemPayload {
  clientMutationId: String
  viewer: Viewer
  toDoItem: ToDoItemsEdge
}

# input type for ToDoItem
input updateToDoItemInput {
  clientMutationId: String
  id: ID
  name: String
  description: String
  done: Boolean
  dueToDate: Date
  createdAt: Date
  updatedAt: Date
  user: embedUserInput
  userUnlink: embedUserInput
  userCreate: createUserInput
  createdBy: embedUserInput
  createdByUnlink: embedUserInput
  createdByCreate: createUserInput
  updateBy: embedUserInput
  updateByUnlink: embedUserInput
  updateByCreate: createUserInput
}

# Payload type for ToDoItem
type updateToDoItemPayload {
  clientMutationId: String
  viewer: Viewer
  toDoItem: ToDoItem
}

# input type for ToDoItem
input deleteToDoItemInput {
  clientMutationId: String
  id: ID
}

# Payload type for ToDoItem
type deleteToDoItemPayload {
  clientMutationId: String
  viewer: Viewer
  deletedItemId: ID
  toDoItem: ToDoItem
}

  # Input types for basic CUD

# input type for User

type UpdateUserSubscriptionPayload {

  id: ID
  userName: String
  password: String
  isAdmin: Boolean
  isSystem: Boolean
  enabled: Boolean
}

type UserSubscription {
  mutation: MutationKind!
  node: User!
  payload: UserSubscriptionPayload
  updatedFields: [String]
  previous: UpdateUserSubscriptionPayload
}

type UserHasManyTodosArgsSubscriptionPayload {
  user:ID!
  toDoItem:ID!
}

type UserHasManyTodosSubscriptionPayload {
  args:UserHasManyTodosArgsSubscriptionPayload
  relation: String
}

union UserSubscriptionPayload = UpdateUserSubscriptionPayload | UserHasManyTodosSubscriptionPayload
  # Input types for basic CUD

# input type for ToDoItem

type UpdateToDoItemSubscriptionPayload {

  id: ID
  name: String
  description: String
  done: Boolean
  dueToDate: Date
  createdAt: Date
  updatedAt: Date
}

type ToDoItemSubscription {
  mutation: MutationKind!
  node: ToDoItem!
  payload: ToDoItemSubscriptionPayload
  updatedFields: [String]
  previous: UpdateToDoItemSubscriptionPayload
}

type ToDoItemBelongsToUserArgsSubscriptionPayload {
  toDoItem:ID!
  user:ID!
}

type ToDoItemBelongsToUserSubscriptionPayload {
  args:ToDoItemBelongsToUserArgsSubscriptionPayload
  relation: String
}

type ToDoItemBelongsToCreatedByArgsSubscriptionPayload {
  toDoItem:ID!
  user:ID!
}

type ToDoItemBelongsToCreatedBySubscriptionPayload {
  args:ToDoItemBelongsToCreatedByArgsSubscriptionPayload
  relation: String
}

type ToDoItemBelongsToUpdateByArgsSubscriptionPayload {
  toDoItem:ID!
  user:ID!
}

type ToDoItemBelongsToUpdateBySubscriptionPayload {
  args:ToDoItemBelongsToUpdateByArgsSubscriptionPayload
  relation: String
}

union ToDoItemSubscriptionPayload = UpdateToDoItemSubscriptionPayload | ToDoItemBelongsToUserSubscriptionPayload | ToDoItemBelongsToCreatedBySubscriptionPayload | ToDoItemBelongsToUpdateBySubscriptionPayload
  type UsersConnection {
  pageInfo: PageInfo!
  edges: [UsersEdge]
  # put here your additional connection fields
}

type UsersEdge {
  node: User
  cursor: String!
  # put here your additiona edge fields
}



type UserHasManyTodosConnection {
  pageInfo: PageInfo!
  edges: [UserHasManyTodosEdge]
  # put here your additional connection fields
}

type UserHasManyTodosEdge {
  node: ToDoItem
  cursor: String!
  # put here your additiona edge fields
}


  type ToDoItemsConnection {
  pageInfo: PageInfo!
  edges: [ToDoItemsEdge]
  # put here your additional connection fields
}

type ToDoItemsEdge {
  node: ToDoItem
  cursor: String!
  # put here your additiona edge fields
}



  
input addToUserHasManyTodosInput {
  clientMutationId: String
  user:ID!
  toDoItem:ID!
  #additional Edge fields
}

type addToUserHasManyTodosPayload {
  clientMutationId: String
  viewer: Viewer
  user: User
 }

input removeFromUserHasManyTodosInput {
  clientMutationId: String
  toDoItem:ID!
  user:ID!
 }

type removeFromUserHasManyTodosPayload {
  clientMutationId: String
  viewer: Viewer
  user: User
 }

  
input addToToDoItemBelongsToUserInput {
  clientMutationId: String
  toDoItem:ID!
  user:ID!
  #additional Edge fields
}

type addToToDoItemBelongsToUserPayload {
  clientMutationId: String
  viewer: Viewer
  toDoItem: ToDoItem
 }

input removeFromToDoItemBelongsToUserInput {
  clientMutationId: String
  user:ID!
  toDoItem:ID!
 }

type removeFromToDoItemBelongsToUserPayload {
  clientMutationId: String
  viewer: Viewer
  toDoItem: ToDoItem
 }

input addToToDoItemBelongsToCreatedByInput {
  clientMutationId: String
  toDoItem:ID!
  user:ID!
  #additional Edge fields
}

type addToToDoItemBelongsToCreatedByPayload {
  clientMutationId: String
  viewer: Viewer
  toDoItem: ToDoItem
 }

input removeFromToDoItemBelongsToCreatedByInput {
  clientMutationId: String
  user:ID!
  toDoItem:ID!
 }

type removeFromToDoItemBelongsToCreatedByPayload {
  clientMutationId: String
  viewer: Viewer
  toDoItem: ToDoItem
 }

input addToToDoItemBelongsToUpdateByInput {
  clientMutationId: String
  toDoItem:ID!
  user:ID!
  #additional Edge fields
}

type addToToDoItemBelongsToUpdateByPayload {
  clientMutationId: String
  viewer: Viewer
  toDoItem: ToDoItem
 }

input removeFromToDoItemBelongsToUpdateByInput {
  clientMutationId: String
  user:ID!
  toDoItem:ID!
 }

type removeFromToDoItemBelongsToUpdateByPayload {
  clientMutationId: String
  viewer: Viewer
  toDoItem: ToDoItem
 }

  
      interface Node {
        id: ID!
      }
      

      type Viewer implements Node {
        id: ID!
          users( after: String, first: Int, before: String, last: Int, limit: Int, skip: Int, orderBy: [UserSortOrder], filter: UserFilter): UsersConnection
  user(id: ID, userName: String): User
    toDoItems( after: String, first: Int, before: String, last: Int, limit: Int, skip: Int, orderBy: [ToDoItemSortOrder], filter: ToDoItemFilter): ToDoItemsConnection
  toDoItem(id: ID): ToDoItem
  _acl(mutation: [String!]): JSON
      }

      type RootQuery {
        
        node(id: ID!): Node
      
  
        viewer: Viewer
      
    users( after: String, first: Int, before: String, last: Int, limit: Int, skip: Int, orderBy: [UserSortOrder], filter: UserComplexFilter): UsersConnection

  user(id: ID, userName: String): User
    toDoItems( after: String, first: Int, before: String, last: Int, limit: Int, skip: Int, orderBy: [ToDoItemSortOrder], filter: ToDoItemComplexFilter): ToDoItemsConnection

  toDoItem(id: ID): ToDoItem
  _acl(mutation: [String!]): JSON
      }

      type RootMutation {
        loginUser(input: loginUserInput!): loginUserPayload
  registerUser(input: registerUserInput!): registerUserPayload
  createUser(input: createUserInput!): createUserPayload
updateUser(input: updateUserInput!): updateUserPayload
deleteUser(input: deleteUserInput!): deleteUserPayload
  createToDoItem(input: createToDoItemInput!): createToDoItemPayload
updateToDoItem(input: updateToDoItemInput!): updateToDoItemPayload
deleteToDoItem(input: deleteToDoItemInput!): deleteToDoItemPayload
  addToUserHasManyTodos(input: addToUserHasManyTodosInput):addToUserHasManyTodosPayload
removeFromUserHasManyTodos(input: removeFromUserHasManyTodosInput):removeFromUserHasManyTodosPayload

  addToToDoItemBelongsToUser(input: addToToDoItemBelongsToUserInput):addToToDoItemBelongsToUserPayload
removeFromToDoItemBelongsToUser(input: removeFromToDoItemBelongsToUserInput):removeFromToDoItemBelongsToUserPayload
addToToDoItemBelongsToCreatedBy(input: addToToDoItemBelongsToCreatedByInput):addToToDoItemBelongsToCreatedByPayload
removeFromToDoItemBelongsToCreatedBy(input: removeFromToDoItemBelongsToCreatedByInput):removeFromToDoItemBelongsToCreatedByPayload
addToToDoItemBelongsToUpdateBy(input: addToToDoItemBelongsToUpdateByInput):addToToDoItemBelongsToUpdateByPayload
removeFromToDoItemBelongsToUpdateBy(input: removeFromToDoItemBelongsToUpdateByInput):removeFromToDoItemBelongsToUpdateByPayload

      }

      type RootSubscription {
        User(filter: UserFilterSubscriptions): UserSubscription

  ToDoItem(filter: ToDoItemFilterSubscriptions): ToDoItemSubscription

      }

      schema {
        query: RootQuery
        mutation: RootMutation
        subscription: RootSubscription
      }
      